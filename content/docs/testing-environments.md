---
id: testing-environments
title: Среды тестирования
permalink: docs/testing-environments.html
prev: testing-recipes.html
---

<!-- Этот документ предназначен для людей, которые знают, как использовать JavaScript и умеют писать тесты. Он показывает различия в средах тестирования React-компонентов и как эти различия повлияют на тесты, которые они пишут. Документ, по большей части, про react-dom-компоненты для веб и частично про другие рендереры. -->

Этот документ рассказывает про факторы, которые могут повлиять на среду тестирования и даёт рекомендации для некоторых случаев.

### Исполнители тестов {#test-runners}

Исполнители тестов, такие как [Jest](https://jestjs.io/), [mocha](https://mochajs.org/), [ava](https://github.com/avajs/ava), позволяют писать тесты на JavaScript и запускать их в процессе разработки. Кроме того, наборы тестов запускаются в рамках непрерывной интеграции.

- Jest хорошо совместим с React-проектами, поддерживает такие возможности, как фиктивные [модули](#mocking-modules) и [таймеры](#mocking-timers), работа с [`jsdom`](#mocking-a-rendering-surface). **Если вы используете Create React App, [Jest уже предустановлен](https://facebook.github.io/create-react-app/docs/running-tests) с полезными настройками по умолчанию.**
- Библиотеки, такие как [mocha](https://mochajs.org/#running-mocha-in-the-browser), хорошо работают в среде с настоящим браузером и помогут в тестах, которым она требуется.
- «Сквозные» тесты нужны для тестирования длинных последовательностей действий через несколько страниц и требуют [другой настройки](#end-to-end-tests-aka-e2e-tests).

### Подмена области рендеринга {#mocking-a-rendering-surface}

Тесты часто запускаются в среде, у которой нет доступа к реальной области рендеринга, например браузера. В этом случае мы рекомендуем имитировать работу браузера с помощью [`jsdom`](https://github.com/jsdom/jsdom) – легковесной реализации браузера, которая запускается в Node.js.

В большинстве случаев, `jsdom` ведёт себя как обычный браузер, но без некоторых возможностей, например [разметки и навигации](https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform). Несмотря на это, `jsdom` полезен в большинстве тестов компонентов для веб, так как выполняется быстрее, чем запуск браузера для каждого отдельного теста. Он также запускается рядом с вашими тестами, что позволяет писать код для сравнения отрендеренного DOM с ожидаемым результатом.

Как настоящий браузер, `jsdom` имитируют действия пользователя: тесты могут создавать события на DOM-узлах, наблюдать за ними и проверять предполагаемые побочные эффекты от этих действий [<small>(пример)</small>](/docs/testing-recipes.html#events).

Большое количество UI-тестов можно написать описанным выше способом: Jest запускает тесты, компонент рендерится в `jsdom`, действия пользователя описываются в виде последовательности браузерных событий и оборачиваются вспомогательной функцией `act()` [<small>(пример)</small>](/docs/testing-recipes.html#act). Кстати, много тестов для библиотеки React написано таким образом.

Если вы пишете библиотеку, которая в основном тестирует поведение специфичное для браузера, например, работа с разметкой страницы или настоящие элементы `input`, используйте фреймворк, такой как [mocha.](https://mochajs.org/)

В среде, где вы _не можете_ имитировать DOM (например, тестирование компонентов React Native в Node.js), используйте [вспомогательные функции имитации события](/docs/test-utils.html#simulate), чтобы имитировать взаимодействие с элементами. В качестве альтернативы можно использовать вспомогательную функцию `fireEvent` из [`@testing-library/react-native`](https://testing-library.com/docs/react-native-testing-library/intro).

Фреймворки, такие как [Cypress](https://www.cypress.io/), [puppeteer](https://github.com/GoogleChrome/puppeteer) и [webdriver](https://www.seleniumhq.org/projects/webdriver/) полезны для запуска [«сквозных» тестов](#end-to-end-tests-aka-e2e-tests).

### Подмена функций {#mocking-functions}

При написании тестов иногда требуется подменить части кода, которые не имеют аналога внутри среды тестирования (например, проверка статуса через `navigator.onLine` внутри Node.js). Тесты могут «следить» за некоторыми функциями и видеть, как другие части теста взаимодействуют с ними. В этом случае полезно иметь возможность выборочно подменять эти функции на удобные для тестирования версии.

Это особенно удобно при получении данных. Обычно, предпочтительнее использовать «подставные» данные для тестов, чтобы избежать замедления и странного поведения, чем получать данные из настоящих API. [<small>(пример)</small>](/docs/testing-recipes.html#data-fetching). Это сделает тесты более предсказуемыми. Библиотеки, такие как [Jest](https://jestjs.io/) и [sinon](https://sinonjs.org/), поддерживают подмену функций. В «сквозных» тестах, подменить сетевой интерфейс будет тяжелее, но вы, возможно, захотите протестировать и настоящие API в таких тестах.

### Фиктивные модули {#mocking-modules}

Некоторые компоненты имеют зависимости в виде модулей, которые могут неправильно работать внутри тестовой среды или совсем не нужны при тестировании. Выборочная подмена таких модулей на фиктивные может быть полезна [<small>(пример)</small>](/docs/testing-recipes.html#mocking-modules).

В Node.js исполнители тестов, например Jest [поддерживает фиктивные модули](https://jestjs.io/docs/ru/manual-mocks). Также вы можете использовать библиотеки, такие как [`mock-require`](https://www.npmjs.com/package/mock-require).

### Фиктивные таймеры {#mocking-timers}

<<<<<<< HEAD
Компоненты могут использовать функции, связанные с временем, такие как `setTimeout`, `setInterval` или `Date.now`. В средах тестирования может быть полезно подменить такие функции на фиктивные, что позволит «двигаться» во времени. Это отличный способ ускорить выполнение тестов! Тесты с таймерами будут по-прежнему выполнятся по порядку, только быстрее. [<small>(пример)</small>](/docs/testing-recipes.html#timers). Большинство фреймворков, включая [Jest](https://jestjs.io/docs/en/timer-mocks), [sinon](https://sinonjs.org/releases/v7.3.2/fake-timers/) и [lolex](https://github.com/sinonjs/lolex), позволяют подменять таймеры в тестах.
=======
Components might be using time-based functions like `setTimeout`, `setInterval`, or `Date.now`. In testing environments, it can be helpful to mock these functions out with replacements that let you manually "advance" time. This is great for making sure your tests run fast! Tests that are dependent on timers would still resolve in order, but quicker [<small>(example)</small>](/docs/testing-recipes.html#timers). Most frameworks, including [Jest](https://jestjs.io/docs/en/timer-mocks), [sinon](https://sinonjs.org/releases/latest/fake-timers) and [lolex](https://github.com/sinonjs/lolex), let you mock timers in your tests.
>>>>>>> 38bf76a4a7bec6072d086ce8efdeef9ebb7af227

Иногда фиктивные таймеры не нужны. Например, при тестировании анимации или взаимодействии с удалённым API, который чувствителен к времени (имеет ограничение по частоте доступа). Библиотеки с фиктивными таймерами позволяют включать и выключать их для одного теста или набора в целом, так что вы можете явно указать как эти тесты будут исполняться.

### «Сквозные» тесты {#end-to-end-tests-aka-e2e-tests}

«Сквозные» тесты полезны при тестировании длинных последовательностей действий, особенно тех, что важны для бизнеса (таких как платежи или регистрация пользователей). Для таких тестов, вы скорее всего, хотите протестировать рендеринг всего приложения в настоящем браузере, получение данных из настоящих API, использование сессий и кук, переходы по ссылкам. Ещё вы, возможно, захотите проверить вероятный результат не только состояния DOM, но и сохранения данных (например, проверить были ли изменения сохранены в базе данных).

В этом случае вам стоит использовать фреймворк [Cypress](https://www.cypress.io/), [Playwright](https://playwright.dev) или библиотеку [Puppeteer](https://pptr.dev/) так вы сможете перемещаться между несколькими маршрутами и проверять вероятные побочные эффекты не только в браузере, но и, возможно, на бэкенде.
